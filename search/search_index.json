{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>Hi I am Areen Churi</code>","text":"<p>About me</p> <ul> <li>Hello I am Areen</li> <li>I'm studying in SRMIST KTR</li> <li>The branch I have chosen is Electronics and Computer Engineering</li> <li>Interested in Python</li> <li>Interested in Web Development</li> <li>Beginner programmer</li> </ul>"},{"location":"code/","title":"DSA portfolio","text":""},{"location":"code/#insertion-in-circular-linked-lists","title":"Insertion in Circular Linked Lists","text":"<p> <pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nstruct Node\n{\n  int data;\n  struct Node *next;\n};\nvoid insertStart (struct Node **head, int data)\n{\n  struct Node *newNode = (struct Node *) malloc (sizeof (struct Node));\n  newNode-&gt;data = data;\n\n  // if its the first node being entered\n  if (*head == NULL)\n    {\n      *head = newNode;\n      (*head)-&gt;next = *head;\n      return;\n    }\n\n  // if LL already as &gt;=1 node\n  struct Node *curr = *head;\n\n  // traverse till last node in LL\n  while (curr-&gt;next != *head)\n    {\n      curr = curr-&gt;next;\n    }\n  // assign LL's last node's next as this new node\n  curr-&gt;next = newNode;\n\n  // assign newNode's next as current head\n  newNode-&gt;next = *head;\n\n  // change head to this new node\n  *head = newNode;\n}\n\nvoid insertLast (struct Node **head, int data)\n{\n  struct Node *newNode = (struct Node *) malloc (sizeof (struct Node));\n  newNode-&gt;data = data;\n\n  // if its the first node being entered\n  if (*head == NULL)\n    {\n      *head = newNode;\n      (*head)-&gt;next = *head;\n      return;\n    }\n\n  // if LL already as &gt;=1 node\n  struct Node *curr = *head;\n\n  // traverse till last node in LL\n  while (curr-&gt;next != *head)\n    {\n      curr = curr-&gt;next;\n    }\n\n  // assign LL's current last node's next as this new node\n  curr-&gt;next = newNode;\n\n  // assign this new node's next as current head of LL\n  newNode-&gt;next = *head;\n}\n\nint getCurrSize (struct Node *node)\n{\n  int size = 0;\n\n  while (node != NULL)\n    {\n      node = node-&gt;next;\n      size++;\n    }\n  return size;\n}\n\nvoid insertPosition (int data, int pos, struct Node **head) \n//function to insert element at specific position\n{\n  struct Node *newnode, *curNode;\n  int i;\n\n  if (*head == NULL)\n    {\n      printf (\"List is empty\");\n    }\n  if (pos == 1)\n    {\n      insertStart (head, data);\n      return;\n    }\n  else\n    {\n      newnode = (struct Node *) malloc (sizeof (struct Node));\n      newnode-&gt;data = data;\n      curNode = *head;\n      while (--pos &gt; 1)\n    {\n      curNode = curNode-&gt;next;\n    }\n      newnode-&gt;next = curNode-&gt;next;\n      curNode-&gt;next = newnode;\n    }\n}\n\nvoid display (struct Node *head)\n{\n  // if there are no node in LL\n  if (head == NULL)\n    return;\n\n  struct Node *temp = head;\n\n  //need to take care of circular structure of LL\n  do\n    {\n      printf (\"%d \", temp-&gt;data);\n      temp = temp-&gt;next;\n\n    }\n  while (temp != head);\n  printf (\"\\n\");\n}\n\nint main ()\n{\n\n  struct Node *head = NULL;\n\n  printf(\"Insert at beginning: \");\n  insertStart (&amp;head, 2);\n  insertStart (&amp;head, 1);\n  display (head);\n\n  printf(\"Insert at End: \");\n  insertLast (&amp;head, 30);\n  insertLast (&amp;head, 40);\n  display (head);\n\n  printf(\"Insert at Specific Position: \");\n  insertPosition (5, 3, &amp;head);\n  display (head);\n\n  return 0;\n}\n</code></pre></p>"},{"location":"code/#deletion-in-circular-linked-lists","title":"Deletion in Circular Linked Lists","text":"<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n// structure for Circular Linked List\nstruct Node\n{\n  int data;\n  struct Node *next;\n};\n\nint calcSize (struct Node *head);\n\nvoid deleteBegin (struct Node **head)\n{\n\n  struct Node *tempNode = *head;\n\n  // if there are no nodes in Linked List can't delete\n  if (*head == NULL)\n    {\n      printf (\"Linked List Empty, nothing to delete\");\n      return;\n    }\n\n  // if only 1 node in CLL\n  if (tempNode-&gt;next == *head)\n    {\n      *head = NULL;\n      return;\n    }\n\n  struct Node *curr = *head;\n\n  // traverse till last node in CLL\n  while (curr-&gt;next != *head)\n    curr = curr-&gt;next;\n\n  // assign last node's next to 2nd node in CLL\n  curr-&gt;next = (*head)-&gt;next;\n\n  // move head to next node\n  *head = (*head)-&gt;next;\n  free (tempNode);\n}\n\nvoid deleteEnd (struct Node **head)\n{\n  struct Node *tempNode = *head;\n  struct Node *previous;\n\n  // if there are no nodes in Linked List can't delete\n  if (*head == NULL)\n    {\n      printf (\"Linked List Empty, nothing to delete\");\n      return;\n    }\n\n  // if Linked List has only 1 node\n  if (tempNode-&gt;next == *head)\n    {\n      *head = NULL;\n      return;\n    }\n\n  // else traverse to the last node\n  while (tempNode-&gt;next != *head)\n    {\n      // store previous link node as we need to change its next val\n      previous = tempNode;\n      tempNode = tempNode-&gt;next;\n    }\n  // Curr assign 2nd last node's next to head\n  previous-&gt;next = *head;\n  // delete the last node\n  free (tempNode);\n  // 2nd last now becomes the last node\n}\n\nvoid deletePos (struct Node **head, int n)\n{\n\n  int size = calcSize (*head);\n\n  if (n &lt; 1 || size &lt; n)\n    {\n      printf (\"Can't delete, %d is not a valid position\\n\", n);\n    }\n  else if (n == 1)\n    deleteBegin (head);\n  else if (n == size)\n    deleteEnd (head);\n  else\n    {\n      struct Node *tempNode = *head;\n      struct Node *previous;    // traverse to the nth node\n      while (--n)\n    { // store previous link node as we need to change its next val \n      previous = tempNode;\n      tempNode = tempNode-&gt;next;\n    }\n\n      // change previous node's next node to nth node's next node\n      previous-&gt;next = tempNode-&gt;next;\n      // delete this nth node\n      free (tempNode);\n    }\n}\n\nvoid insert (struct Node **head, int data)\n{\n  struct Node *newNode = (struct Node *) malloc (sizeof (struct Node));\n  newNode-&gt;data = data;\n\n  if (*head == NULL)\n    {\n      *head = newNode;\n      (*head)-&gt;next = *head;\n      return;\n    }\n\n  struct Node *curr = *head;\n\n  while (curr-&gt;next != *head)\n    {\n      curr = curr-&gt;next;\n    }\n\n  curr-&gt;next = newNode;\n  newNode-&gt;next = *head;\n  *head = newNode;\n}\n\nint calcSize (struct Node *head)\n{\n  int size = 0;\n  struct Node *temp = head;\n\n  if (temp == NULL)\n    return size;\n\n  do\n    {\n      size++;\n      temp = temp-&gt;next;\n\n    }\n  while (temp != head);\n\n  return size;\n}\n\nvoid display (struct Node *head)\n{\n  // if there are no node in CLL\n  if (head == NULL)\n    return;\n\n  struct Node *temp = head;\n\n  //need to take care of circular structure of CLL\n  do\n    {\n      printf (\"%d \", temp-&gt;data);\n      temp = temp-&gt;next;\n\n    }\n  while (temp != head);\n  printf (\"\\n\");\n}\n\nint main ()\n{\n\n  // first node will be null at creation    \n  struct Node *head = NULL;\n\n  insert (&amp;head, 10);\n  insert (&amp;head, 11);\n  insert (&amp;head, 12);\n  insert (&amp;head, 13);\n  insert (&amp;head, 14);\n  insert (&amp;head, 15);\n  insert (&amp;head, 16);\n\n  display (head);\n\n  deleteBegin (&amp;head);\n  display (head);\n\n  deleteEnd (&amp;head);\n  display (head);\n\n  deletePos (&amp;head, 3);\n  display (head);\n\n  return 0;\n}\n</code></pre>"},{"location":"code/#traversal-of-circular-linked-lists","title":"Traversal of Circular Linked lists","text":"<p> <pre><code>/* Function to traverse a given Circular linked list and print nodes */\nvoid printList(struct Node *first)\n{\n    struct Node *temp = first; \n\n    // If linked list is not empty\n    if (first != NULL) \n    {\n        // Keep printing nodes till we reach the first node again\n        do\n        {\n            printf(\"%d \", temp-&gt;data);\n            temp = temp-&gt;next;\n        }\n        while (temp != first);\n    }\n}\n</code></pre></p>"},{"location":"code/#insertion-in-doubly-circular-linked-lists","title":"Insertion in Doubly Circular Linked Lists","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Structure of a node\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    newNode-&gt;prev = NULL;\n    return newNode;\n}\n\n// Function to insert a node at the beginning of the list\nvoid insertAtBeginning(struct Node** head, int data) {\n    struct Node* newNode = createNode(data);\n    if (*head == NULL) {\n        newNode-&gt;next = newNode;\n        newNode-&gt;prev = newNode;\n        *head = newNode;\n    } else {\n        newNode-&gt;next = *head;\n        newNode-&gt;prev = (*head)-&gt;prev;\n        (*head)-&gt;prev-&gt;next = newNode;\n        (*head)-&gt;prev = newNode;\n        *head = newNode;\n    }\n}\n\n// Function to insert a node at the end of the list\nvoid insertAtEnd(struct Node** head, int data) {\n    if (*head == NULL) {\n        insertAtBeginning(head, data);\n        return;\n    }\n    struct Node* newNode = createNode(data);\n    newNode-&gt;next = *head;\n    newNode-&gt;prev = (*head)-&gt;prev;\n    (*head)-&gt;prev-&gt;next = newNode;\n    (*head)-&gt;prev = newNode;\n}\n\n// Function to insert a node at the middle of the list\nvoid insertAtMiddle(struct Node** head, int data, int position) {\n    if (position &lt;= 0) {\n        printf(\"Invalid position\\n\");\n        return;\n    }\n    if (position == 1) {\n        insertAtBeginning(head, data);\n        return;\n    }\n    struct Node* newNode = createNode(data);\n    struct Node* current = *head;\n    for (int i = 1; i &lt; position - 1 &amp;&amp; current-&gt;next != *head; i++) {\n        current = current-&gt;next;\n    }\n    if (current-&gt;next == *head) {\n        printf(\"Position out of range\\n\");\n        return;\n    }\n    newNode-&gt;next = current-&gt;next;\n    newNode-&gt;prev = current;\n    current-&gt;next-&gt;prev = newNode;\n    current-&gt;next = newNode;\n}\n\n// Function to display the list\nvoid displayList(struct Node* head) {\n    if (head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* current = head;\n    do {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    } while (current != head);\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    struct Node* head = NULL;\n\n    // Inserting nodes\n    insertAtBeginning(&amp;head, 10);\n    insertAtEnd(&amp;head, 20);\n    insertAtMiddle(&amp;head, 15, 2);\n\n    // Displaying the list\n    printf(\"Doubly Circular Linked List: \");\n    displayList(head);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"code/#deletion-in-doubly-circular-linked-lists","title":"Deletion in Doubly Circular Linked Lists","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Structure of a node\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    newNode-&gt;prev = NULL;\n    return newNode;\n}\n\n// Function to insert a node at the beginning of the list\nvoid insertAtBeginning(struct Node** head, int data) {\n    struct Node* newNode = createNode(data);\n    if (*head == NULL) {\n        newNode-&gt;next = newNode;\n        newNode-&gt;prev = newNode;\n        *head = newNode;\n    } else {\n        newNode-&gt;next = *head;\n        newNode-&gt;prev = (*head)-&gt;prev;\n        (*head)-&gt;prev-&gt;next = newNode;\n        (*head)-&gt;prev = newNode;\n        *head = newNode;\n    }\n}\n\n// Function to delete a node from the beginning of the list\nvoid deleteFromBeginning(struct Node** head) {\n    if (*head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* temp = *head;\n    if ((*head)-&gt;next == *head) {\n        *head = NULL;\n    } else {\n        (*head)-&gt;prev-&gt;next = (*head)-&gt;next;\n        (*head)-&gt;next-&gt;prev = (*head)-&gt;prev;\n        *head = (*head)-&gt;next;\n    }\n    free(temp);\n}\n\n// Function to delete a node from the end of the list\nvoid deleteFromEnd(struct Node** head) {\n    if (*head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* temp = (*head)-&gt;prev;\n    if ((*head)-&gt;next == *head) {\n        *head = NULL;\n    } else {\n        temp-&gt;prev-&gt;next = *head;\n        (*head)-&gt;prev = temp-&gt;prev;\n    }\n    free(temp);\n}\n\n// Function to delete a node from the middle of the list\nvoid deleteFromMiddle(struct Node** head, int position) {\n    if (*head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    if (position &lt;= 0) {\n        printf(\"Invalid position\\n\");\n        return;\n    }\n    if (position == 1) {\n        deleteFromBeginning(head);\n        return;\n    }\n    struct Node* current = *head;\n    for (int i = 1; i &lt; position &amp;&amp; current-&gt;next != *head; i++) {\n        current = current-&gt;next;\n    }\n    if (current-&gt;next == *head) {\n        printf(\"Position out of range\\n\");\n        return;\n    }\n    current-&gt;prev-&gt;next = current-&gt;next;\n    current-&gt;next-&gt;prev = current-&gt;prev;\n    free(current);\n}\n\n// Function to display the list\nvoid displayList(struct Node* head) {\n    if (head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* current = head;\n    do {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    } while (current != head);\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    struct Node* head = NULL;\n\n    // Inserting nodes\n    insertAtBeginning(&amp;head, 10);\n    insertAtBeginning(&amp;head, 20);\n    insertAtBeginning(&amp;head, 30);\n    insertAtBeginning(&amp;head, 40);\n\n    // Displaying the list\n    printf(\"Doubly Circular Linked List: \");\n    displayList(head);\n\n    // Deleting nodes\n    deleteFromBeginning(&amp;head);\n    deleteFromEnd(&amp;head);\n    deleteFromMiddle(&amp;head, 2);\n\n    // Displaying the list after deletion\n    printf(\"Doubly Circular Linked List after deletion: \");\n    displayList(head);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"code/#traversal-of-doubly-circular-linked-lists","title":"Traversal of Doubly Circular Linked lists","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Structure of a node\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    newNode-&gt;prev = NULL;\n    return newNode;\n}\n\n// Function to insert a node at the beginning of the list\nvoid insertAtBeginning(struct Node** head, int data) {\n    struct Node* newNode = createNode(data);\n    if (*head == NULL) {\n        newNode-&gt;next = newNode;\n        newNode-&gt;prev = newNode;\n        *head = newNode;\n    } else {\n        newNode-&gt;next = *head;\n        newNode-&gt;prev = (*head)-&gt;prev;\n        (*head)-&gt;prev-&gt;next = newNode;\n        (*head)-&gt;prev = newNode;\n        *head = newNode;\n    }\n}\n\n// Function to traverse and print the doubly circular linked list\nvoid traverseList(struct Node* head) {\n    if (head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* current = head;\n    do {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    } while (current != head);\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    struct Node* head = NULL;\n\n    // Inserting nodes\n    insertAtBeginning(&amp;head, 10);\n    insertAtBeginning(&amp;head, 20);\n    insertAtBeginning(&amp;head, 30);\n    insertAtBeginning(&amp;head, 40);\n\n    // Displaying the list\n    printf(\"Doubly Circular Linked List: \");\n    traverseList(head);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"code/#double-ended-queue-operation","title":"Double Ended Queue Operation","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Structure of a node\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// Structure of a deque\nstruct Deque {\n    struct Node* front;\n    struct Node* rear;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    newNode-&gt;prev = NULL;\n    return newNode;\n}\n\n// Function to initialize a deque\nstruct Deque* initializeDeque() {\n    struct Deque* deque = (struct Deque*)malloc(sizeof(struct Deque));\n    if (deque == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    deque-&gt;front = NULL;\n    deque-&gt;rear = NULL;\n    return deque;\n}\n\n// Function to insert an element at the front of the deque\nvoid insertFront(struct Deque* deque, int data) {\n    struct Node* newNode = createNode(data);\n    if (deque-&gt;front == NULL) {\n        deque-&gt;front = newNode;\n        deque-&gt;rear = newNode;\n    } else {\n        newNode-&gt;next = deque-&gt;front;\n        deque-&gt;front-&gt;prev = newNode;\n        deque-&gt;front = newNode;\n    }\n}\n\n// Function to insert an element at the rear of the deque\nvoid insertRear(struct Deque* deque, int data) {\n    struct Node* newNode = createNode(data);\n    if (deque-&gt;rear == NULL) {\n        deque-&gt;front = newNode;\n        deque-&gt;rear = newNode;\n    } else {\n        newNode-&gt;prev = deque-&gt;rear;\n        deque-&gt;rear-&gt;next = newNode;\n        deque-&gt;rear = newNode;\n    }\n}\n\n// Function to delete an element from the front of the deque\nvoid deleteFront(struct Deque* deque) {\n    if (deque-&gt;front == NULL) {\n        printf(\"Deque is empty\\n\");\n        return;\n    }\n    struct Node* temp = deque-&gt;front;\n    deque-&gt;front = deque-&gt;front-&gt;next;\n    if (deque-&gt;front == NULL) {\n        deque-&gt;rear = NULL;\n    } else {\n        deque-&gt;front-&gt;prev = NULL;\n    }\n    free(temp);\n}\n\n// Function to delete an element from the rear of the deque\nvoid deleteRear(struct Deque* deque) {\n    if (deque-&gt;rear == NULL) {\n        printf(\"Deque is empty\\n\");\n        return;\n    }\n    struct Node* temp = deque-&gt;rear;\n    deque-&gt;rear = deque-&gt;rear-&gt;prev;\n    if (deque-&gt;rear == NULL) {\n        deque-&gt;front = NULL;\n    } else {\n        deque-&gt;rear-&gt;next = NULL;\n    }\n    free(temp);\n}\n\n// Function to display the elements of the deque\nvoid displayDeque(struct Deque* deque) {\n    if (deque-&gt;front == NULL) {\n        printf(\"Deque is empty\\n\");\n        return;\n    }\n    struct Node* current = deque-&gt;front;\n    while (current != NULL) {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    }\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    struct Deque* deque = initializeDeque();\n\n    // Inserting elements at front and rear\n    insertFront(deque, 10);\n    insertFront(deque, 20);\n    insertRear(deque, 30);\n    insertRear(deque, 40);\n\n    // Displaying the deque\n    printf(\"Deque: \");\n    displayDeque(deque);\n\n    // Deleting elements from front and rear\n    deleteFront(deque);\n    deleteRear(deque);\n\n    // Displaying the deque after deletion\n    printf(\"Deque after deletion: \");\n    displayDeque(deque);\n\n    // Freeing allocated memory\n    free(deque);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"code/#hashing","title":"Hashing","text":""},{"location":"code/#question-what-is-hashing","title":"question: \"What is Hashing?\",","text":"<p>answer: Hashing is a mathematical function that converts data into a string of letters and numbers that can't be reversed or decoded. Hashing is used in cybersecurity to protect sensitive information like passwords, documents, and messages. The process uses hash functions and algorithms to assign a numeric value to a string, which makes data retrieval faster and enables encryption <pre><code>unsigned long hash_function(const char *key, int array_size) {\nunsigned long hash_value = 0;\nconst char *c;\nfor (c = key; *c != '\\\\0'; ++c) {\n  hash_value += *c;\n}\nreturn hash_value % array_size;\n}\n</code></pre></p>"},{"location":"code/#question-why-hashing","title":"question: \"Why Hashing?\",","text":"<p>answer: Applications:</p> <p>Hashing has numerous applications across computer science. Here are a few common ones:</p> <ul> <li>Data Integrity</li> <li>Data Lookups</li> <li>Password Storage</li> </ul>"},{"location":"code/#b-trees","title":"B+ Trees","text":""},{"location":"code/#question-what-is-a-b-tree","title":"question: \"What is a B+ Tree?\",","text":"<p>answer: A B+ Tree is a self-balancing tree data structure designed for efficient searching and retrieval of data, particularly for large datasets stored on disk. It's an improvement over Binary Search Trees (BSTs) due to its ability to handle larger amounts of data efficiently. <pre><code># Traversing a B+ Tree\nvoid inOrderTraversal(struct bPlusTreeNode *node) {\nif (node != NULL) {\n// If it's not a leaf node, recurse on the left child\nif (!node-&gt;isLeaf) {\n  inOrderTraversal(node-&gt;children[0]);\n}\n\n// Print all keys in the current node\nfor (int i = 0; i &lt; node-&gt;numKeys; i++) {\n  printf(\"%d \", node-&gt;keys[i]);\n}\n\n// If it's not a leaf node, recurse on the right children (up to numKeys)\nif (!node-&gt;isLeaf) {\n  for (int i = 0; i &lt; node-&gt;numKeys + 1; i++) {\n    inOrderTraversal(node-&gt;children[i]);\n  }\n}\n}\n}\n</code></pre></p>"},{"location":"code/#question-why-use-b-trees-need-and-applications","title":"question: \"Why Use B+ Trees? - Need and Applications\",","text":"<p>answer: B+ Trees are widely used in database management systems and file systems due to their efficiency in handling large amounts of data. Here are a few reasons why B+ Trees are preferred over other data structures:  </p> <ul> <li>Efficient Searching </li> <li>Disk-Based Storage </li> <li>Range Queries</li> <li>Sequential Access</li> </ul>"},{"location":"code/#heaps","title":"Heaps","text":""},{"location":"code/#question-what-are-heaps","title":"question: \"What are Heaps?\",","text":"<p>answer: A Heap is a specialized tree-based data structure that satisfies the heap property. It's commonly used to implement priority queues and sorting algorithms. There are two main types of heaps:</p> <pre><code>- Max Heap \n- Min Heap.\n\n// Inserting an Element into a Max Heap\nvoid insertMaxHeap(int heap[], int n, int key) {\nn = n + 1;\nint i = n - 1;\nheap[i] = key;\n\n// Fix the max heap property\nwhile (i != 0 &amp;&amp; heap[parent(i)] &lt; heap[i]) {\nswap(&amp;heap[i], &amp;heap[parent(i)]);\ni = parent(i);\n}\n}\n</code></pre>"},{"location":"code/#question-application-of-heaps","title":"question: \"Application of Heaps\",","text":"<p>answer: Applications of Heaps: </p> <ul> <li>Priority Queues </li> <li>Dijkstra's Algorithm </li> <li>Heap Sort </li> <li>Memory Management </li> <li>Job Scheduling</li> </ul>"},{"location":"code/#binomial-heaps","title":"Binomial Heaps","text":""},{"location":"code/#question-what-are-binomial-heaps","title":"question: \"What are Binomial Heaps?\",","text":"<p>answer: Binomial heaps are a specialized type of tree-based data structure designed for efficient merging operations. They are less commonly used than basic heaps (min-heaps and max-heaps) but find applications in more advanced algorithms where frequent merging is needed. <pre><code>// Merging Two Binomial Heaps\nstruct Node* mergeBinomialHeaps(struct Node* h1, struct Node* h2) {\nstruct Node* h = NULL;\nstruct Node* temp = NULL;\nstruct Node* x = h1;\nstruct Node* y = h2;\n\nwhile (x != NULL &amp;&amp; y != NULL) {\nif (x-&gt;degree &lt;= y-&gt;degree) {\n  temp = x;\n  x = x-&gt;sibling;\n} else {\n  temp = y;\n  y = y-&gt;sibling;\n}\n\ntemp-&gt;sibling = h;\nh = temp;\n}\n\nwhile (x != NULL) {\ntemp = x;\nx = x-&gt;sibling;\ntemp-&gt;sibling = h;\nh = temp;\n}\n\nwhile (y != NULL) {\ntemp = y;\ny = y-&gt;sibling;\ntemp-&gt;sibling = h;\nh = temp;\n}\n\nreturn h;\n}\n</code></pre></p>"},{"location":"code/#question-properties-of-binomial-heaps","title":"question: \"Properties of Binomial Heaps\",","text":"<p>answer: Properties of Binomial Heaps:</p> <ul> <li>A Binomial Heap of order k has 2^k nodes.</li> <li>A Binomial Heap of order k has kCj nodes at depth j.</li> <li>The number of nodes in a Binomial Heap of order k is 2^k.</li> <li>The height of a Binomial Heap of order k is k.</li> </ul>"},{"location":"hobbies/","title":"<code>Hobbies</code>","text":"<p>My Hobbies</p> <ul> <li>Reading books</li> <li>Playing games</li> <li>Watching movies</li> <li>Listening to music</li> <li>Hanging out with friends</li> </ul> <p>My Achievements</p> <ul> <li>Won TechnoFest 23, conducted by faculty</li> <li>Participated in AI hackathon</li> <li>3rd price in innofusion '24</li> </ul>"}]}